#!/usr/bin/env python3

import sqlite3
import pandas as pd
import logging
from pathlib import Path

# === Logging ===
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - master_warp - %(levelname)s - %(message)s'
)
logger = logging.getLogger("master_warp")

# === Config ===
PROJECT_ROOT = Path(__file__).resolve().parents[2]
DB_PATH = PROJECT_ROOT / "src" / "data" / "WARP.db"
MASTER_TABLE = "master_warp"

def load_table(conn, table_name):
    return pd.read_sql_query(f"SELECT * FROM {table_name}", conn)

def build_master_table():
    logger.info(f"📦 Using database: {DB_PATH}")
    if not DB_PATH.exists():
        raise FileNotFoundError(f"❌ Database not found: {DB_PATH}")

    conn = sqlite3.connect(DB_PATH)

    try:
        logger.info("📥 Laden van alle brontabellen")
        df_time = load_table(conn, "dim_datetime")
        df_entsoe = load_table(conn, "transform_entsoe_obs")
        df_weather = load_table(conn, "transform_weather_obs")
        df_ned = load_table(conn, "transform_ned_obs")
        df_forecast = load_table(conn, "transform_meteo_forecast_now")

        # Normaliseer kolomnamen naar datetime
        df_entsoe.rename(columns={"Timestamp": "datetime"}, inplace=True)
        df_weather.rename(columns={"date": "datetime"}, inplace=True)
        df_ned.rename(columns={"ned.validto": "datetime"}, inplace=True)
        df_forecast.rename(columns={"date": "datetime"}, inplace=True)

        # Datatypes forceren
        for df in [df_time, df_entsoe, df_weather, df_ned, df_forecast]:
            df["datetime"] = pd.to_datetime(df["datetime"], utc=True)

        # Combineer observatie + forecast vóór merge
        logger.info("🔁 Samenvoegen observaties + voorspellingen")
        df_weather_combined = pd.merge(df_forecast, df_weather, on="datetime", how="outer")

        for col in df_weather.columns:
            if col != "datetime":
                col_forecast = f"{col}_x"
                col_obs = f"{col}_y"
                if col_forecast in df_weather_combined and col_obs in df_weather_combined:
                    df_weather_combined[col] = df_weather_combined[col_obs].combine_first(df_weather_combined[col_forecast])

        # Alleen clean kolommen overhouden
        weather_cols = ["datetime"] + [c for c in df_weather.columns if c != "datetime"]
        df_weather = df_weather_combined[weather_cols]

        # 🔗 Final merge
        logger.info("🔗 Joinen op datetime")
        df = df_time \
            .merge(df_entsoe, on="datetime", how="left") \
            .merge(df_weather, on="datetime", how="left") \
            .merge(df_ned, on="datetime", how="left")

        logger.info(f"✅ Gekoppeld resultaat: {df.shape[0]} rijen, {df.shape[1]} kolommen")

        logger.info(f"📊 Nulls vóór imputatie:\n{df.isna().sum()[df.isna().sum() > 0]}")

        df = df.fillna(0)

        logger.info(f"💾 Wegschrijven naar {MASTER_TABLE}")
        df.to_sql(MASTER_TABLE, conn, if_exists="replace", index=False)

        logger.info("🎉 master_warp succesvol opgebouwd en opgeslagen (NaNs → 0).")
    except Exception as e:
        logger.error(f"❌ Fout bij bouwen van master_warp: {e}", exc_info=True)
    finally:
        conn.close()
        logger.info("🔒 Verbinding gesloten")

if __name__ == "__main__":
    build_master_table()